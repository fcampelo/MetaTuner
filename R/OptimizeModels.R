#' Optimize regression models to estimate new configurations
#'
#' @param parameters data frame containing information about the tunable
#'                   parameters
#' @param models list containing models generated by [FitModels()].
#' @param optimization.method optimization method to be used
#' @param ndigits number of significant digits to use for each parameter.
#'
#' @return list containing new candidate configurations found by optimization
#'
#'
#' @author Felipe Campelo (\email{fcampelo@@ufmg.br}),
#'         Athila Trindade (\email{rochaathila@@gmail.com})
#'
#' @export

OptimizeModels <- function(parameters,
                           models,
                           optimization.method = "Nelder-Mead",
                           ndigits){

  # ========== Error checking
  if(length(ndigits) == 1) ndigits <- rep(ndigits, times = nrow(parameters))
  assertthat::assert_that(is.data.frame(parameters),
                          all(parameters$minx < parameters$maxx),
                          nrow(parameters) > 0,
                          is.numeric(ndigits),
                          all(ndigits > 0),
                          all(ndigits == round(ndigits)))


  # ========== Prepare matrix of new configurations
  mysample <- matrix(as.numeric(NA),
                     nrow = length(models),
                     ncol = nrow(parameters))


  # ========== Prepare optimization parameters
  # Objective function
  myobjfun <- function(x, model){
    modclass <- class(model)
    x        <- as.data.frame(matrix(x, nrow = 1))
    names(x) <- names(model$model)[-1]

    if (modclass == "lm"){
      y <- stats::predict.lm(object  = model,
                             newdata = x)
    } else if (modclass == "rq"){
      y <- quantreg::predict.rq(object  = model,
                                newdata = x)
    } else stop("Model class", modclass,
                "not recognized by function OptimizeModels")

    return(sign(y) * min(1e32, abs(y)))
  }

  # Box constraints
  ci <- rep(c(0, -1), each = nrow(parameters))
  Ui <- diag(nrow = nrow(parameters),
             ncol = nrow(parameters))
  Ui <- rbind(Ui, -Ui)
  # print(Ui)
  # cat("\n", ci)

  # ========== Optimize (minimize) models
  cat("\nOptimizing Models: ")
  # PARALLELIZE HERE
  # VVVVVVVVVVVVVVVV
    for (i in seq(models)){
    # Initial point for optimization (random, feasible)
    theta <- runif(nrow(parameters))
    # cat("\n", theta)

    Y <- stats::constrOptim(theta  = theta,
                            f      = myobjfun,
                            grad   = NULL,
                            ui     = Ui,
                            ci     = ci,
                            method = optimization.method,
                            model  = models[[i]])
    mysample[i, ] <- Y$par
    cat(".")
  }


  for (j in 1:ncol(mysample)){
    mysample[, j] <- signif(mysample[, j], digits = ndigits[j])
  }

  # ========== Return new configurations
  newconfs <- apply(X      = mysample,
                    MARGIN = 1,
                    FUN    = function(x){
                      list(config = x,
                           Yij    = data.frame(instance.ID = character(),
                                               y           = numeric(),
                                               stringsAsFactors = FALSE),
                           perf   = NA)})
  return(newconfs)

}
